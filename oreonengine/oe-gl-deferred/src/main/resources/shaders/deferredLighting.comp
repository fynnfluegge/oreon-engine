#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba16f) uniform writeonly image2D defferedSceneImage;

layout (binding = 2, rgba16f) uniform readonly image2DMS albedoSceneImage;

layout (binding = 3, rgba32f) uniform readonly image2DMS worldPositionImage;

layout (binding = 4, rgba32f) uniform readonly image2DMS normalImage;

layout (binding = 5, rgba16f)   uniform readonly image2DMS specularEmissionImage;

layout (binding = 6, r8) uniform readonly image2D sampleCoverageMask;

layout (binding = 7, r16f) uniform readonly image2D ssaoBlurImage;

layout (std140, row_major) uniform Camera{
	vec3 eyePosition;
	mat4 m_View;
	mat4 m_ViewProjection;
	vec4 frustumPlanes[6];
};

layout (std140) uniform DirectionalLight{
	vec3 direction;
	float intensity;
	vec3 ambient;
	vec3 color;
} directional_light;

layout (std140, row_major) uniform LightViewProjections{
	mat4 m_lightViewProjection[6];
	float splitRange[6];
};

uniform sampler2DArray pssm;
uniform int numSamples;
uniform float sightRangeFactor;
uniform int ssaoFlag;
uniform vec3 fogColor;

const float zfar = 10000;
const float znear = 0.1;

float diffuse(vec3 direction, vec3 normal, float intensity)
{
	return max(0.0, dot(normal, -direction) * intensity);
}

float specular(vec3 direction, vec3 normal, vec3 eyePosition, vec3 vertexPosition, float specularFactor, float emissionFactor)
{
	vec3 reflectionVector = normalize(reflect(direction, normal));
	vec3 vertexToEye = normalize(eyePosition - vertexPosition);
	
	float specular = max(0.0, dot(vertexToEye, reflectionVector));
	
	return pow(specular, specularFactor) * emissionFactor;
}

float getFogFactor(float dist)
{
	return smoothstep(0,1,-0.0002/sightRangeFactor*(dist-(zfar)/10*sightRangeFactor) + 1);
}

float linearizeDepth(float depth)
{
	return (2 * znear) / (zfar + znear - depth * (zfar - znear));
}

float percentageCloserShadows(vec3 projCoords, int split, float shadowFactor){

	float currentDepth = projCoords.z;
	float shadowMapDepth = texture(pssm, vec3(projCoords.xy,split)).r;
	
	float dist = linearizeDepth(shadowMapDepth) - linearizeDepth(currentDepth);
		
	if (dist < 0)
		return 0;
	else 
		return 1;
}

float varianceShadow(vec3 projCoords, int split, int kernels){
	
	float shadowFactor = 1.0;
	float texelSize = 1.0/ 4096.0;
	float currentDepth = projCoords.z;
	float reduceFactor = 1/ pow(kernels*2+1,2);
	
	for (int i=-kernels; i<=kernels; i++){
		for (int j=-kernels; j<=kernels; j++){
			float shadowMapDepth = texture(pssm, vec3(projCoords.xy,split)
													   + vec3(i,j,0) * texelSize).r; 
			if (currentDepth > shadowMapDepth)
				shadowFactor -= reduceFactor;
		}
	}
	
	return max(0.1,shadowFactor);
}


float applyShadowMapping(vec3 worldPos)
{
	float shadowFactor = 0;
	vec3 projCoords = vec3(0,0,0);
	float linDepth = (m_View * vec4(worldPos,1)).z/zfar;
	if (linDepth < splitRange[0]){
		vec4 lightSpacePos = m_lightViewProjection[0] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		float shadowFactor0 = varianceShadow(projCoords,0,4);
		
		lightSpacePos = m_lightViewProjection[1] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		float shadowFactor1 = varianceShadow(projCoords,1,4);
		
		lightSpacePos = m_lightViewProjection[2] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		float shadowFactor2 = varianceShadow(projCoords,2,2);
		
		shadowFactor = min(shadowFactor2, min(shadowFactor0,shadowFactor1));
	}
	else if (linDepth < splitRange[1]){
		vec4 lightSpacePos = m_lightViewProjection[1] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		float shadowFactor0 = varianceShadow(projCoords,1,4);
		
		lightSpacePos = m_lightViewProjection[2] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		float shadowFactor1 = varianceShadow(projCoords,2,2);
		
		shadowFactor = min(shadowFactor0,shadowFactor1);
	}
	else if (linDepth < splitRange[2]){
		vec4 lightSpacePos = m_lightViewProjection[2] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,2,2);
	}
	else if (linDepth < splitRange[3]){
		vec4 lightSpacePos = m_lightViewProjection[3] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,3,2);
	}
	else if (linDepth < splitRange[4]){
		vec4 lightSpacePos = m_lightViewProjection[4] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,4,1); 
	}
	else if (linDepth < splitRange[5]){
		vec4 lightSpacePos = m_lightViewProjection[5] * vec4(worldPos,1.0);
		projCoords = lightSpacePos.xyz * 0.5 + 0.5;
		shadowFactor = varianceShadow(projCoords,5,1); 
	}
	else return 1;
	
	return shadowFactor;
}

void main(void){

	ivec2 computeCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	
	vec3 finalColor = vec3(0,0,0);
	vec3 albedo = vec3(0,0,0);
	vec3 position = vec3(0,0,0);
	vec3 normal = vec3(0,0,0);
	vec2 specular_emission = vec2(0,0);
	vec3 depth = vec3(0,0,0);
	
	float diff = 0;
	float shadow = 0;
	float spec = 0;
	
	if(imageLoad(sampleCoverageMask, computeCoord).r == 1.0){
		
		for (int i=0; i<numSamples; i++){
			
			albedo = imageLoad(albedoSceneImage, computeCoord,i).rgb; 
			normal = imageLoad(normalImage, computeCoord,i).rbg; 
			
			// prevent lighting atmosphere
			if (normal != vec3(0,0,0)){
				position = imageLoad(worldPositionImage, computeCoord,i).rgb; 
				specular_emission = imageLoad(specularEmissionImage, computeCoord,i).rg; 
			
				diff = diffuse(directional_light.direction, normal, directional_light.intensity);
				spec = specular(directional_light.direction, normal, eyePosition, position, specular_emission.r, specular_emission.g);
				shadow = applyShadowMapping(position);
				float ssao = imageLoad(ssaoBlurImage, computeCoord).r;
				
				vec3 diffuseLight = directional_light.ambient + directional_light.color * diff * shadow;
				vec3 specularLight = directional_light.color * spec;
				
				if (ssaoFlag == 1)
					finalColor += albedo * diffuseLight * ssao + specularLight;
				else 
					finalColor += albedo * diffuseLight + specularLight;
			}
			else{
				finalColor += albedo;
			}
		}
		finalColor /= numSamples;
	}
	else {
		
		albedo = imageLoad(albedoSceneImage, computeCoord,0).rgb;
		normal = imageLoad(normalImage, computeCoord,0).rbg;
		
		if (normal != vec3(0,0,0)){
			position = imageLoad(worldPositionImage, computeCoord,0).rgb;
			specular_emission = imageLoad(specularEmissionImage, computeCoord,0).rg;
		
			diff = diffuse(directional_light.direction, normal, directional_light.intensity);
			spec = specular(directional_light.direction, normal, eyePosition, position, specular_emission.r, specular_emission.g);
			shadow = applyShadowMapping(position);
			float ssao = imageLoad(ssaoBlurImage, computeCoord).r;
			
			vec3 diffuseLight = directional_light.ambient + directional_light.color * diff * shadow;
			vec3 specularLight = directional_light.color * spec;
			
			if (ssaoFlag == 1)
				finalColor = albedo * diffuseLight * ssao + specularLight;
			else 
				finalColor = albedo * diffuseLight + specularLight;
		}
		else{
			finalColor = albedo;
		}
	}
	
	float dist = length(eyePosition - imageLoad(worldPositionImage, computeCoord,0).rgb);
	float fogFactor = getFogFactor(dist);
	if (imageLoad(normalImage, computeCoord,0).rbg != vec3(0,0,0))
	{
		finalColor = mix(fogColor, finalColor, clamp(fogFactor,0,1));
	}
	
	imageStore(defferedSceneImage, computeCoord, vec4(finalColor,1.0));
}